Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADD
    BREAK
    CONT
    DIVIDE
    EYE
    MULTIPLY
    ONES
    PRINT
    RETURN
    SUBTRACT
    ZEROS

Grammar

Rule 0     S' -> program
Rule 1     program -> segment
Rule 2     program -> <empty>
Rule 3     segment -> segment segment
Rule 4     segment -> group
Rule 5     line -> expression ;
Rule 6     block -> { segment }
Rule 7     for -> FOR ID = range group
Rule 8     range -> value_element : value_element
Rule 9     while -> WHILE ( logical_expression ) group
Rule 10    if -> IF ( logical_expression ) group
Rule 11    if -> IF ( logical_expression ) group ELSE group
Rule 12    group -> conditional
Rule 13    group -> line
Rule 14    group -> block
Rule 15    conditional -> if
Rule 16    conditional -> while
Rule 17    conditional -> for
Rule 18    value_element -> ID
Rule 19    value_element -> arithmetic_expression
Rule 20    value_element -> FLOAT
Rule 21    value_element -> INT
Rule 22    value_element -> STRING
Rule 23    value_element -> - value_element
Rule 24    value_element -> value_element TRANSPOSE
Rule 25    value_element -> matrix_definition
Rule 26    matrix_definition -> [ matrix_definition_inside ]
Rule 27    matrix_definition_inside -> matrix_definition_inside matrix_definition_inside
Rule 28    matrix_definition_inside -> value_element ,
Rule 29    arithmetic_expression -> value_element arithmetic_operator value_element
Rule 30    arithmetic_operator -> +
Rule 31    arithmetic_operator -> -
Rule 32    arithmetic_operator -> *
Rule 33    arithmetic_operator -> /
Rule 34    arithmetic_operator -> MTX_SUM
Rule 35    arithmetic_operator -> MTX_DIFFERENCE
Rule 36    arithmetic_operator -> MTX_PRODUCT
Rule 37    arithmetic_operator -> MTX_QUOTIENT
Rule 38    expression -> logical_expression
Rule 39    expression -> assignment
Rule 40    expression -> value_element
Rule 41    logical_expression -> value_element comparison_operator value_element
Rule 42    comparison_operator -> <
Rule 43    comparison_operator -> >
Rule 44    comparison_operator -> EQUAL
Rule 45    comparison_operator -> NOT_EQUAL
Rule 46    comparison_operator -> SMALLER_OR_EQUAL
Rule 47    comparison_operator -> LARGER_OR_EQUAL
Rule 48    assignment -> ID = value_element

Terminals, with rules where they appear

(                    : 9 10 11
)                    : 9 10 11
*                    : 32
+                    : 30
,                    : 28
-                    : 23 31
/                    : 33
:                    : 8
;                    : 5
<                    : 42
=                    : 7 48
>                    : 43
ADD                  : 
BREAK                : 
CONT                 : 
DIVIDE               : 
ELSE                 : 11
EQUAL                : 44
EYE                  : 
FLOAT                : 20
FOR                  : 7
ID                   : 7 18 48
IF                   : 10 11
INT                  : 21
LARGER_OR_EQUAL      : 47
MTX_DIFFERENCE       : 35
MTX_PRODUCT          : 36
MTX_QUOTIENT         : 37
MTX_SUM              : 34
MULTIPLY             : 
NOT_EQUAL            : 45
ONES                 : 
PRINT                : 
RETURN               : 
SMALLER_OR_EQUAL     : 46
STRING               : 22
SUBTRACT             : 
TRANSPOSE            : 24
WHILE                : 9
ZEROS                : 
[                    : 26
]                    : 26
error                : 
{                    : 6
}                    : 6

Nonterminals, with rules where they appear

arithmetic_expression : 19
arithmetic_operator  : 29
assignment           : 39
block                : 14
comparison_operator  : 41
conditional          : 12
expression           : 5
for                  : 17
group                : 4 7 9 10 11 11
if                   : 15
line                 : 13
logical_expression   : 9 10 11 38
matrix_definition    : 25
matrix_definition_inside : 26 27 27
program              : 0
range                : 7
segment              : 1 3 3 6
value_element        : 8 8 23 24 28 29 29 40 41 41 48
while                : 16

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . segment
    (2) program -> .
    (3) segment -> . segment segment
    (4) segment -> . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    $end            reduce using rule 2 (program -> .)
    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    program                        shift and go to state 1
    segment                        shift and go to state 2
    group                          shift and go to state 3
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    logical_expression             shift and go to state 13
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 1

    (0) S' -> program .



state 2

    (1) program -> segment .
    (3) segment -> segment . segment
    (3) segment -> . segment segment
    (4) segment -> . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    $end            reduce using rule 1 (program -> segment .)
    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    segment                        shift and go to state 26
    group                          shift and go to state 3
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    logical_expression             shift and go to state 13
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 3

    (4) segment -> group .

    {               reduce using rule 4 (segment -> group .)
    IF              reduce using rule 4 (segment -> group .)
    WHILE           reduce using rule 4 (segment -> group .)
    FOR             reduce using rule 4 (segment -> group .)
    ID              reduce using rule 4 (segment -> group .)
    FLOAT           reduce using rule 4 (segment -> group .)
    INT             reduce using rule 4 (segment -> group .)
    STRING          reduce using rule 4 (segment -> group .)
    -               reduce using rule 4 (segment -> group .)
    [               reduce using rule 4 (segment -> group .)
    $end            reduce using rule 4 (segment -> group .)
    }               reduce using rule 4 (segment -> group .)


state 4

    (12) group -> conditional .

    {               reduce using rule 12 (group -> conditional .)
    IF              reduce using rule 12 (group -> conditional .)
    WHILE           reduce using rule 12 (group -> conditional .)
    FOR             reduce using rule 12 (group -> conditional .)
    ID              reduce using rule 12 (group -> conditional .)
    FLOAT           reduce using rule 12 (group -> conditional .)
    INT             reduce using rule 12 (group -> conditional .)
    STRING          reduce using rule 12 (group -> conditional .)
    -               reduce using rule 12 (group -> conditional .)
    [               reduce using rule 12 (group -> conditional .)
    $end            reduce using rule 12 (group -> conditional .)
    }               reduce using rule 12 (group -> conditional .)
    ELSE            reduce using rule 12 (group -> conditional .)


state 5

    (13) group -> line .

    {               reduce using rule 13 (group -> line .)
    IF              reduce using rule 13 (group -> line .)
    WHILE           reduce using rule 13 (group -> line .)
    FOR             reduce using rule 13 (group -> line .)
    ID              reduce using rule 13 (group -> line .)
    FLOAT           reduce using rule 13 (group -> line .)
    INT             reduce using rule 13 (group -> line .)
    STRING          reduce using rule 13 (group -> line .)
    -               reduce using rule 13 (group -> line .)
    [               reduce using rule 13 (group -> line .)
    $end            reduce using rule 13 (group -> line .)
    }               reduce using rule 13 (group -> line .)
    ELSE            reduce using rule 13 (group -> line .)


state 6

    (14) group -> block .

    {               reduce using rule 14 (group -> block .)
    IF              reduce using rule 14 (group -> block .)
    WHILE           reduce using rule 14 (group -> block .)
    FOR             reduce using rule 14 (group -> block .)
    ID              reduce using rule 14 (group -> block .)
    FLOAT           reduce using rule 14 (group -> block .)
    INT             reduce using rule 14 (group -> block .)
    STRING          reduce using rule 14 (group -> block .)
    -               reduce using rule 14 (group -> block .)
    [               reduce using rule 14 (group -> block .)
    $end            reduce using rule 14 (group -> block .)
    }               reduce using rule 14 (group -> block .)
    ELSE            reduce using rule 14 (group -> block .)


state 7

    (15) conditional -> if .

    {               reduce using rule 15 (conditional -> if .)
    IF              reduce using rule 15 (conditional -> if .)
    WHILE           reduce using rule 15 (conditional -> if .)
    FOR             reduce using rule 15 (conditional -> if .)
    ID              reduce using rule 15 (conditional -> if .)
    FLOAT           reduce using rule 15 (conditional -> if .)
    INT             reduce using rule 15 (conditional -> if .)
    STRING          reduce using rule 15 (conditional -> if .)
    -               reduce using rule 15 (conditional -> if .)
    [               reduce using rule 15 (conditional -> if .)
    $end            reduce using rule 15 (conditional -> if .)
    }               reduce using rule 15 (conditional -> if .)
    ELSE            reduce using rule 15 (conditional -> if .)


state 8

    (16) conditional -> while .

    {               reduce using rule 16 (conditional -> while .)
    IF              reduce using rule 16 (conditional -> while .)
    WHILE           reduce using rule 16 (conditional -> while .)
    FOR             reduce using rule 16 (conditional -> while .)
    ID              reduce using rule 16 (conditional -> while .)
    FLOAT           reduce using rule 16 (conditional -> while .)
    INT             reduce using rule 16 (conditional -> while .)
    STRING          reduce using rule 16 (conditional -> while .)
    -               reduce using rule 16 (conditional -> while .)
    [               reduce using rule 16 (conditional -> while .)
    $end            reduce using rule 16 (conditional -> while .)
    }               reduce using rule 16 (conditional -> while .)
    ELSE            reduce using rule 16 (conditional -> while .)


state 9

    (17) conditional -> for .

    {               reduce using rule 17 (conditional -> for .)
    IF              reduce using rule 17 (conditional -> for .)
    WHILE           reduce using rule 17 (conditional -> for .)
    FOR             reduce using rule 17 (conditional -> for .)
    ID              reduce using rule 17 (conditional -> for .)
    FLOAT           reduce using rule 17 (conditional -> for .)
    INT             reduce using rule 17 (conditional -> for .)
    STRING          reduce using rule 17 (conditional -> for .)
    -               reduce using rule 17 (conditional -> for .)
    [               reduce using rule 17 (conditional -> for .)
    $end            reduce using rule 17 (conditional -> for .)
    }               reduce using rule 17 (conditional -> for .)
    ELSE            reduce using rule 17 (conditional -> for .)


state 10

    (5) line -> expression . ;

    ;               shift and go to state 27


state 11

    (6) block -> { . segment }
    (3) segment -> . segment segment
    (4) segment -> . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    segment                        shift and go to state 28
    group                          shift and go to state 3
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    logical_expression             shift and go to state 13
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 12

    (10) if -> IF . ( logical_expression ) group
    (11) if -> IF . ( logical_expression ) group ELSE group

    (               shift and go to state 29


state 13

    (38) expression -> logical_expression .

    ;               reduce using rule 38 (expression -> logical_expression .)


state 14

    (9) while -> WHILE . ( logical_expression ) group

    (               shift and go to state 30


state 15

    (7) for -> FOR . ID = range group

    ID              shift and go to state 31


state 16

    (48) assignment -> ID . = value_element
    (18) value_element -> ID .

    =               shift and go to state 32
    TRANSPOSE       reduce using rule 18 (value_element -> ID .)
    <               reduce using rule 18 (value_element -> ID .)
    >               reduce using rule 18 (value_element -> ID .)
    EQUAL           reduce using rule 18 (value_element -> ID .)
    NOT_EQUAL       reduce using rule 18 (value_element -> ID .)
    SMALLER_OR_EQUAL reduce using rule 18 (value_element -> ID .)
    LARGER_OR_EQUAL reduce using rule 18 (value_element -> ID .)
    +               reduce using rule 18 (value_element -> ID .)
    -               reduce using rule 18 (value_element -> ID .)
    *               reduce using rule 18 (value_element -> ID .)
    /               reduce using rule 18 (value_element -> ID .)
    MTX_SUM         reduce using rule 18 (value_element -> ID .)
    MTX_DIFFERENCE  reduce using rule 18 (value_element -> ID .)
    MTX_PRODUCT     reduce using rule 18 (value_element -> ID .)
    MTX_QUOTIENT    reduce using rule 18 (value_element -> ID .)
    ;               reduce using rule 18 (value_element -> ID .)


state 17

    (39) expression -> assignment .

    ;               reduce using rule 39 (expression -> assignment .)


state 18

    (40) expression -> value_element .
    (41) logical_expression -> value_element . comparison_operator value_element
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (42) comparison_operator -> . <
    (43) comparison_operator -> . >
    (44) comparison_operator -> . EQUAL
    (45) comparison_operator -> . NOT_EQUAL
    (46) comparison_operator -> . SMALLER_OR_EQUAL
    (47) comparison_operator -> . LARGER_OR_EQUAL
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

    ;               reduce using rule 40 (expression -> value_element .)
    TRANSPOSE       shift and go to state 34
    <               shift and go to state 36
    >               shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    SMALLER_OR_EQUAL shift and go to state 40
    LARGER_OR_EQUAL shift and go to state 41
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

    comparison_operator            shift and go to state 33
    arithmetic_operator            shift and go to state 35

state 19

    (19) value_element -> arithmetic_expression .

    TRANSPOSE       reduce using rule 19 (value_element -> arithmetic_expression .)
    <               reduce using rule 19 (value_element -> arithmetic_expression .)
    >               reduce using rule 19 (value_element -> arithmetic_expression .)
    EQUAL           reduce using rule 19 (value_element -> arithmetic_expression .)
    NOT_EQUAL       reduce using rule 19 (value_element -> arithmetic_expression .)
    SMALLER_OR_EQUAL reduce using rule 19 (value_element -> arithmetic_expression .)
    LARGER_OR_EQUAL reduce using rule 19 (value_element -> arithmetic_expression .)
    +               reduce using rule 19 (value_element -> arithmetic_expression .)
    -               reduce using rule 19 (value_element -> arithmetic_expression .)
    *               reduce using rule 19 (value_element -> arithmetic_expression .)
    /               reduce using rule 19 (value_element -> arithmetic_expression .)
    MTX_SUM         reduce using rule 19 (value_element -> arithmetic_expression .)
    MTX_DIFFERENCE  reduce using rule 19 (value_element -> arithmetic_expression .)
    MTX_PRODUCT     reduce using rule 19 (value_element -> arithmetic_expression .)
    MTX_QUOTIENT    reduce using rule 19 (value_element -> arithmetic_expression .)
    ;               reduce using rule 19 (value_element -> arithmetic_expression .)
    ,               reduce using rule 19 (value_element -> arithmetic_expression .)
    )               reduce using rule 19 (value_element -> arithmetic_expression .)
    :               reduce using rule 19 (value_element -> arithmetic_expression .)
    {               reduce using rule 19 (value_element -> arithmetic_expression .)
    IF              reduce using rule 19 (value_element -> arithmetic_expression .)
    WHILE           reduce using rule 19 (value_element -> arithmetic_expression .)
    FOR             reduce using rule 19 (value_element -> arithmetic_expression .)
    ID              reduce using rule 19 (value_element -> arithmetic_expression .)
    FLOAT           reduce using rule 19 (value_element -> arithmetic_expression .)
    INT             reduce using rule 19 (value_element -> arithmetic_expression .)
    STRING          reduce using rule 19 (value_element -> arithmetic_expression .)
    [               reduce using rule 19 (value_element -> arithmetic_expression .)


state 20

    (20) value_element -> FLOAT .

    TRANSPOSE       reduce using rule 20 (value_element -> FLOAT .)
    <               reduce using rule 20 (value_element -> FLOAT .)
    >               reduce using rule 20 (value_element -> FLOAT .)
    EQUAL           reduce using rule 20 (value_element -> FLOAT .)
    NOT_EQUAL       reduce using rule 20 (value_element -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 20 (value_element -> FLOAT .)
    LARGER_OR_EQUAL reduce using rule 20 (value_element -> FLOAT .)
    +               reduce using rule 20 (value_element -> FLOAT .)
    -               reduce using rule 20 (value_element -> FLOAT .)
    *               reduce using rule 20 (value_element -> FLOAT .)
    /               reduce using rule 20 (value_element -> FLOAT .)
    MTX_SUM         reduce using rule 20 (value_element -> FLOAT .)
    MTX_DIFFERENCE  reduce using rule 20 (value_element -> FLOAT .)
    MTX_PRODUCT     reduce using rule 20 (value_element -> FLOAT .)
    MTX_QUOTIENT    reduce using rule 20 (value_element -> FLOAT .)
    ;               reduce using rule 20 (value_element -> FLOAT .)
    ,               reduce using rule 20 (value_element -> FLOAT .)
    )               reduce using rule 20 (value_element -> FLOAT .)
    :               reduce using rule 20 (value_element -> FLOAT .)
    {               reduce using rule 20 (value_element -> FLOAT .)
    IF              reduce using rule 20 (value_element -> FLOAT .)
    WHILE           reduce using rule 20 (value_element -> FLOAT .)
    FOR             reduce using rule 20 (value_element -> FLOAT .)
    ID              reduce using rule 20 (value_element -> FLOAT .)
    FLOAT           reduce using rule 20 (value_element -> FLOAT .)
    INT             reduce using rule 20 (value_element -> FLOAT .)
    STRING          reduce using rule 20 (value_element -> FLOAT .)
    [               reduce using rule 20 (value_element -> FLOAT .)


state 21

    (21) value_element -> INT .

    TRANSPOSE       reduce using rule 21 (value_element -> INT .)
    <               reduce using rule 21 (value_element -> INT .)
    >               reduce using rule 21 (value_element -> INT .)
    EQUAL           reduce using rule 21 (value_element -> INT .)
    NOT_EQUAL       reduce using rule 21 (value_element -> INT .)
    SMALLER_OR_EQUAL reduce using rule 21 (value_element -> INT .)
    LARGER_OR_EQUAL reduce using rule 21 (value_element -> INT .)
    +               reduce using rule 21 (value_element -> INT .)
    -               reduce using rule 21 (value_element -> INT .)
    *               reduce using rule 21 (value_element -> INT .)
    /               reduce using rule 21 (value_element -> INT .)
    MTX_SUM         reduce using rule 21 (value_element -> INT .)
    MTX_DIFFERENCE  reduce using rule 21 (value_element -> INT .)
    MTX_PRODUCT     reduce using rule 21 (value_element -> INT .)
    MTX_QUOTIENT    reduce using rule 21 (value_element -> INT .)
    ;               reduce using rule 21 (value_element -> INT .)
    ,               reduce using rule 21 (value_element -> INT .)
    )               reduce using rule 21 (value_element -> INT .)
    :               reduce using rule 21 (value_element -> INT .)
    {               reduce using rule 21 (value_element -> INT .)
    IF              reduce using rule 21 (value_element -> INT .)
    WHILE           reduce using rule 21 (value_element -> INT .)
    FOR             reduce using rule 21 (value_element -> INT .)
    ID              reduce using rule 21 (value_element -> INT .)
    FLOAT           reduce using rule 21 (value_element -> INT .)
    INT             reduce using rule 21 (value_element -> INT .)
    STRING          reduce using rule 21 (value_element -> INT .)
    [               reduce using rule 21 (value_element -> INT .)


state 22

    (22) value_element -> STRING .

    TRANSPOSE       reduce using rule 22 (value_element -> STRING .)
    <               reduce using rule 22 (value_element -> STRING .)
    >               reduce using rule 22 (value_element -> STRING .)
    EQUAL           reduce using rule 22 (value_element -> STRING .)
    NOT_EQUAL       reduce using rule 22 (value_element -> STRING .)
    SMALLER_OR_EQUAL reduce using rule 22 (value_element -> STRING .)
    LARGER_OR_EQUAL reduce using rule 22 (value_element -> STRING .)
    +               reduce using rule 22 (value_element -> STRING .)
    -               reduce using rule 22 (value_element -> STRING .)
    *               reduce using rule 22 (value_element -> STRING .)
    /               reduce using rule 22 (value_element -> STRING .)
    MTX_SUM         reduce using rule 22 (value_element -> STRING .)
    MTX_DIFFERENCE  reduce using rule 22 (value_element -> STRING .)
    MTX_PRODUCT     reduce using rule 22 (value_element -> STRING .)
    MTX_QUOTIENT    reduce using rule 22 (value_element -> STRING .)
    ;               reduce using rule 22 (value_element -> STRING .)
    ,               reduce using rule 22 (value_element -> STRING .)
    )               reduce using rule 22 (value_element -> STRING .)
    :               reduce using rule 22 (value_element -> STRING .)
    {               reduce using rule 22 (value_element -> STRING .)
    IF              reduce using rule 22 (value_element -> STRING .)
    WHILE           reduce using rule 22 (value_element -> STRING .)
    FOR             reduce using rule 22 (value_element -> STRING .)
    ID              reduce using rule 22 (value_element -> STRING .)
    FLOAT           reduce using rule 22 (value_element -> STRING .)
    INT             reduce using rule 22 (value_element -> STRING .)
    STRING          reduce using rule 22 (value_element -> STRING .)
    [               reduce using rule 22 (value_element -> STRING .)


state 23

    (23) value_element -> - . value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    value_element                  shift and go to state 50
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 24

    (25) value_element -> matrix_definition .

    TRANSPOSE       reduce using rule 25 (value_element -> matrix_definition .)
    <               reduce using rule 25 (value_element -> matrix_definition .)
    >               reduce using rule 25 (value_element -> matrix_definition .)
    EQUAL           reduce using rule 25 (value_element -> matrix_definition .)
    NOT_EQUAL       reduce using rule 25 (value_element -> matrix_definition .)
    SMALLER_OR_EQUAL reduce using rule 25 (value_element -> matrix_definition .)
    LARGER_OR_EQUAL reduce using rule 25 (value_element -> matrix_definition .)
    +               reduce using rule 25 (value_element -> matrix_definition .)
    -               reduce using rule 25 (value_element -> matrix_definition .)
    *               reduce using rule 25 (value_element -> matrix_definition .)
    /               reduce using rule 25 (value_element -> matrix_definition .)
    MTX_SUM         reduce using rule 25 (value_element -> matrix_definition .)
    MTX_DIFFERENCE  reduce using rule 25 (value_element -> matrix_definition .)
    MTX_PRODUCT     reduce using rule 25 (value_element -> matrix_definition .)
    MTX_QUOTIENT    reduce using rule 25 (value_element -> matrix_definition .)
    ;               reduce using rule 25 (value_element -> matrix_definition .)
    ,               reduce using rule 25 (value_element -> matrix_definition .)
    )               reduce using rule 25 (value_element -> matrix_definition .)
    :               reduce using rule 25 (value_element -> matrix_definition .)
    {               reduce using rule 25 (value_element -> matrix_definition .)
    IF              reduce using rule 25 (value_element -> matrix_definition .)
    WHILE           reduce using rule 25 (value_element -> matrix_definition .)
    FOR             reduce using rule 25 (value_element -> matrix_definition .)
    ID              reduce using rule 25 (value_element -> matrix_definition .)
    FLOAT           reduce using rule 25 (value_element -> matrix_definition .)
    INT             reduce using rule 25 (value_element -> matrix_definition .)
    STRING          reduce using rule 25 (value_element -> matrix_definition .)
    [               reduce using rule 25 (value_element -> matrix_definition .)


state 25

    (26) matrix_definition -> [ . matrix_definition_inside ]
    (27) matrix_definition_inside -> . matrix_definition_inside matrix_definition_inside
    (28) matrix_definition_inside -> . value_element ,
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    matrix_definition_inside       shift and go to state 52
    value_element                  shift and go to state 53
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 26

    (3) segment -> segment segment .
    (3) segment -> segment . segment
    (3) segment -> . segment segment
    (4) segment -> . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for [ resolved as shift
    $end            reduce using rule 3 (segment -> segment segment .)
    }               reduce using rule 3 (segment -> segment segment .)
    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

  ! {               [ reduce using rule 3 (segment -> segment segment .) ]
  ! IF              [ reduce using rule 3 (segment -> segment segment .) ]
  ! WHILE           [ reduce using rule 3 (segment -> segment segment .) ]
  ! FOR             [ reduce using rule 3 (segment -> segment segment .) ]
  ! ID              [ reduce using rule 3 (segment -> segment segment .) ]
  ! FLOAT           [ reduce using rule 3 (segment -> segment segment .) ]
  ! INT             [ reduce using rule 3 (segment -> segment segment .) ]
  ! STRING          [ reduce using rule 3 (segment -> segment segment .) ]
  ! -               [ reduce using rule 3 (segment -> segment segment .) ]
  ! [               [ reduce using rule 3 (segment -> segment segment .) ]

    segment                        shift and go to state 26
    group                          shift and go to state 3
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    logical_expression             shift and go to state 13
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 27

    (5) line -> expression ; .

    {               reduce using rule 5 (line -> expression ; .)
    IF              reduce using rule 5 (line -> expression ; .)
    WHILE           reduce using rule 5 (line -> expression ; .)
    FOR             reduce using rule 5 (line -> expression ; .)
    ID              reduce using rule 5 (line -> expression ; .)
    FLOAT           reduce using rule 5 (line -> expression ; .)
    INT             reduce using rule 5 (line -> expression ; .)
    STRING          reduce using rule 5 (line -> expression ; .)
    -               reduce using rule 5 (line -> expression ; .)
    [               reduce using rule 5 (line -> expression ; .)
    $end            reduce using rule 5 (line -> expression ; .)
    }               reduce using rule 5 (line -> expression ; .)
    ELSE            reduce using rule 5 (line -> expression ; .)


state 28

    (6) block -> { segment . }
    (3) segment -> segment . segment
    (3) segment -> . segment segment
    (4) segment -> . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    }               shift and go to state 54
    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    segment                        shift and go to state 26
    group                          shift and go to state 3
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    logical_expression             shift and go to state 13
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 29

    (10) if -> IF ( . logical_expression ) group
    (11) if -> IF ( . logical_expression ) group ELSE group
    (41) logical_expression -> . value_element comparison_operator value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    logical_expression             shift and go to state 55
    value_element                  shift and go to state 56
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 30

    (9) while -> WHILE ( . logical_expression ) group
    (41) logical_expression -> . value_element comparison_operator value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    logical_expression             shift and go to state 57
    value_element                  shift and go to state 56
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 31

    (7) for -> FOR ID . = range group

    =               shift and go to state 58


state 32

    (48) assignment -> ID = . value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    value_element                  shift and go to state 59
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 33

    (41) logical_expression -> value_element comparison_operator . value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    value_element                  shift and go to state 60
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 34

    (24) value_element -> value_element TRANSPOSE .

    TRANSPOSE       reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    <               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    >               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    EQUAL           reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    NOT_EQUAL       reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    SMALLER_OR_EQUAL reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    LARGER_OR_EQUAL reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    +               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    -               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    *               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    /               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    MTX_SUM         reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    MTX_DIFFERENCE  reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    MTX_PRODUCT     reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    MTX_QUOTIENT    reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    ;               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    ,               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    )               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    :               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    {               reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    IF              reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    WHILE           reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    FOR             reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    ID              reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    FLOAT           reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    INT             reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    STRING          reduce using rule 24 (value_element -> value_element TRANSPOSE .)
    [               reduce using rule 24 (value_element -> value_element TRANSPOSE .)


state 35

    (29) arithmetic_expression -> value_element arithmetic_operator . value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    value_element                  shift and go to state 61
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 36

    (42) comparison_operator -> < .

    ID              reduce using rule 42 (comparison_operator -> < .)
    FLOAT           reduce using rule 42 (comparison_operator -> < .)
    INT             reduce using rule 42 (comparison_operator -> < .)
    STRING          reduce using rule 42 (comparison_operator -> < .)
    -               reduce using rule 42 (comparison_operator -> < .)
    [               reduce using rule 42 (comparison_operator -> < .)


state 37

    (43) comparison_operator -> > .

    ID              reduce using rule 43 (comparison_operator -> > .)
    FLOAT           reduce using rule 43 (comparison_operator -> > .)
    INT             reduce using rule 43 (comparison_operator -> > .)
    STRING          reduce using rule 43 (comparison_operator -> > .)
    -               reduce using rule 43 (comparison_operator -> > .)
    [               reduce using rule 43 (comparison_operator -> > .)


state 38

    (44) comparison_operator -> EQUAL .

    ID              reduce using rule 44 (comparison_operator -> EQUAL .)
    FLOAT           reduce using rule 44 (comparison_operator -> EQUAL .)
    INT             reduce using rule 44 (comparison_operator -> EQUAL .)
    STRING          reduce using rule 44 (comparison_operator -> EQUAL .)
    -               reduce using rule 44 (comparison_operator -> EQUAL .)
    [               reduce using rule 44 (comparison_operator -> EQUAL .)


state 39

    (45) comparison_operator -> NOT_EQUAL .

    ID              reduce using rule 45 (comparison_operator -> NOT_EQUAL .)
    FLOAT           reduce using rule 45 (comparison_operator -> NOT_EQUAL .)
    INT             reduce using rule 45 (comparison_operator -> NOT_EQUAL .)
    STRING          reduce using rule 45 (comparison_operator -> NOT_EQUAL .)
    -               reduce using rule 45 (comparison_operator -> NOT_EQUAL .)
    [               reduce using rule 45 (comparison_operator -> NOT_EQUAL .)


state 40

    (46) comparison_operator -> SMALLER_OR_EQUAL .

    ID              reduce using rule 46 (comparison_operator -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 46 (comparison_operator -> SMALLER_OR_EQUAL .)
    INT             reduce using rule 46 (comparison_operator -> SMALLER_OR_EQUAL .)
    STRING          reduce using rule 46 (comparison_operator -> SMALLER_OR_EQUAL .)
    -               reduce using rule 46 (comparison_operator -> SMALLER_OR_EQUAL .)
    [               reduce using rule 46 (comparison_operator -> SMALLER_OR_EQUAL .)


state 41

    (47) comparison_operator -> LARGER_OR_EQUAL .

    ID              reduce using rule 47 (comparison_operator -> LARGER_OR_EQUAL .)
    FLOAT           reduce using rule 47 (comparison_operator -> LARGER_OR_EQUAL .)
    INT             reduce using rule 47 (comparison_operator -> LARGER_OR_EQUAL .)
    STRING          reduce using rule 47 (comparison_operator -> LARGER_OR_EQUAL .)
    -               reduce using rule 47 (comparison_operator -> LARGER_OR_EQUAL .)
    [               reduce using rule 47 (comparison_operator -> LARGER_OR_EQUAL .)


state 42

    (30) arithmetic_operator -> + .

    ID              reduce using rule 30 (arithmetic_operator -> + .)
    FLOAT           reduce using rule 30 (arithmetic_operator -> + .)
    INT             reduce using rule 30 (arithmetic_operator -> + .)
    STRING          reduce using rule 30 (arithmetic_operator -> + .)
    -               reduce using rule 30 (arithmetic_operator -> + .)
    [               reduce using rule 30 (arithmetic_operator -> + .)


state 43

    (31) arithmetic_operator -> - .

    ID              reduce using rule 31 (arithmetic_operator -> - .)
    FLOAT           reduce using rule 31 (arithmetic_operator -> - .)
    INT             reduce using rule 31 (arithmetic_operator -> - .)
    STRING          reduce using rule 31 (arithmetic_operator -> - .)
    -               reduce using rule 31 (arithmetic_operator -> - .)
    [               reduce using rule 31 (arithmetic_operator -> - .)


state 44

    (32) arithmetic_operator -> * .

    ID              reduce using rule 32 (arithmetic_operator -> * .)
    FLOAT           reduce using rule 32 (arithmetic_operator -> * .)
    INT             reduce using rule 32 (arithmetic_operator -> * .)
    STRING          reduce using rule 32 (arithmetic_operator -> * .)
    -               reduce using rule 32 (arithmetic_operator -> * .)
    [               reduce using rule 32 (arithmetic_operator -> * .)


state 45

    (33) arithmetic_operator -> / .

    ID              reduce using rule 33 (arithmetic_operator -> / .)
    FLOAT           reduce using rule 33 (arithmetic_operator -> / .)
    INT             reduce using rule 33 (arithmetic_operator -> / .)
    STRING          reduce using rule 33 (arithmetic_operator -> / .)
    -               reduce using rule 33 (arithmetic_operator -> / .)
    [               reduce using rule 33 (arithmetic_operator -> / .)


state 46

    (34) arithmetic_operator -> MTX_SUM .

    ID              reduce using rule 34 (arithmetic_operator -> MTX_SUM .)
    FLOAT           reduce using rule 34 (arithmetic_operator -> MTX_SUM .)
    INT             reduce using rule 34 (arithmetic_operator -> MTX_SUM .)
    STRING          reduce using rule 34 (arithmetic_operator -> MTX_SUM .)
    -               reduce using rule 34 (arithmetic_operator -> MTX_SUM .)
    [               reduce using rule 34 (arithmetic_operator -> MTX_SUM .)


state 47

    (35) arithmetic_operator -> MTX_DIFFERENCE .

    ID              reduce using rule 35 (arithmetic_operator -> MTX_DIFFERENCE .)
    FLOAT           reduce using rule 35 (arithmetic_operator -> MTX_DIFFERENCE .)
    INT             reduce using rule 35 (arithmetic_operator -> MTX_DIFFERENCE .)
    STRING          reduce using rule 35 (arithmetic_operator -> MTX_DIFFERENCE .)
    -               reduce using rule 35 (arithmetic_operator -> MTX_DIFFERENCE .)
    [               reduce using rule 35 (arithmetic_operator -> MTX_DIFFERENCE .)


state 48

    (36) arithmetic_operator -> MTX_PRODUCT .

    ID              reduce using rule 36 (arithmetic_operator -> MTX_PRODUCT .)
    FLOAT           reduce using rule 36 (arithmetic_operator -> MTX_PRODUCT .)
    INT             reduce using rule 36 (arithmetic_operator -> MTX_PRODUCT .)
    STRING          reduce using rule 36 (arithmetic_operator -> MTX_PRODUCT .)
    -               reduce using rule 36 (arithmetic_operator -> MTX_PRODUCT .)
    [               reduce using rule 36 (arithmetic_operator -> MTX_PRODUCT .)


state 49

    (37) arithmetic_operator -> MTX_QUOTIENT .

    ID              reduce using rule 37 (arithmetic_operator -> MTX_QUOTIENT .)
    FLOAT           reduce using rule 37 (arithmetic_operator -> MTX_QUOTIENT .)
    INT             reduce using rule 37 (arithmetic_operator -> MTX_QUOTIENT .)
    STRING          reduce using rule 37 (arithmetic_operator -> MTX_QUOTIENT .)
    -               reduce using rule 37 (arithmetic_operator -> MTX_QUOTIENT .)
    [               reduce using rule 37 (arithmetic_operator -> MTX_QUOTIENT .)


state 50

    (23) value_element -> - value_element .
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

    <               reduce using rule 23 (value_element -> - value_element .)
    >               reduce using rule 23 (value_element -> - value_element .)
    EQUAL           reduce using rule 23 (value_element -> - value_element .)
    NOT_EQUAL       reduce using rule 23 (value_element -> - value_element .)
    SMALLER_OR_EQUAL reduce using rule 23 (value_element -> - value_element .)
    LARGER_OR_EQUAL reduce using rule 23 (value_element -> - value_element .)
    +               reduce using rule 23 (value_element -> - value_element .)
    -               reduce using rule 23 (value_element -> - value_element .)
    *               reduce using rule 23 (value_element -> - value_element .)
    /               reduce using rule 23 (value_element -> - value_element .)
    MTX_SUM         reduce using rule 23 (value_element -> - value_element .)
    MTX_DIFFERENCE  reduce using rule 23 (value_element -> - value_element .)
    MTX_PRODUCT     reduce using rule 23 (value_element -> - value_element .)
    MTX_QUOTIENT    reduce using rule 23 (value_element -> - value_element .)
    ;               reduce using rule 23 (value_element -> - value_element .)
    ,               reduce using rule 23 (value_element -> - value_element .)
    )               reduce using rule 23 (value_element -> - value_element .)
    :               reduce using rule 23 (value_element -> - value_element .)
    {               reduce using rule 23 (value_element -> - value_element .)
    IF              reduce using rule 23 (value_element -> - value_element .)
    WHILE           reduce using rule 23 (value_element -> - value_element .)
    FOR             reduce using rule 23 (value_element -> - value_element .)
    ID              reduce using rule 23 (value_element -> - value_element .)
    FLOAT           reduce using rule 23 (value_element -> - value_element .)
    INT             reduce using rule 23 (value_element -> - value_element .)
    STRING          reduce using rule 23 (value_element -> - value_element .)
    [               reduce using rule 23 (value_element -> - value_element .)
    TRANSPOSE       shift and go to state 34

  ! TRANSPOSE       [ reduce using rule 23 (value_element -> - value_element .) ]
  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! MTX_SUM         [ shift and go to state 46 ]
  ! MTX_DIFFERENCE  [ shift and go to state 47 ]
  ! MTX_PRODUCT     [ shift and go to state 48 ]
  ! MTX_QUOTIENT    [ shift and go to state 49 ]

    arithmetic_operator            shift and go to state 35

state 51

    (18) value_element -> ID .

    TRANSPOSE       reduce using rule 18 (value_element -> ID .)
    +               reduce using rule 18 (value_element -> ID .)
    -               reduce using rule 18 (value_element -> ID .)
    *               reduce using rule 18 (value_element -> ID .)
    /               reduce using rule 18 (value_element -> ID .)
    MTX_SUM         reduce using rule 18 (value_element -> ID .)
    MTX_DIFFERENCE  reduce using rule 18 (value_element -> ID .)
    MTX_PRODUCT     reduce using rule 18 (value_element -> ID .)
    MTX_QUOTIENT    reduce using rule 18 (value_element -> ID .)
    <               reduce using rule 18 (value_element -> ID .)
    >               reduce using rule 18 (value_element -> ID .)
    EQUAL           reduce using rule 18 (value_element -> ID .)
    NOT_EQUAL       reduce using rule 18 (value_element -> ID .)
    SMALLER_OR_EQUAL reduce using rule 18 (value_element -> ID .)
    LARGER_OR_EQUAL reduce using rule 18 (value_element -> ID .)
    ;               reduce using rule 18 (value_element -> ID .)
    ,               reduce using rule 18 (value_element -> ID .)
    )               reduce using rule 18 (value_element -> ID .)
    :               reduce using rule 18 (value_element -> ID .)
    {               reduce using rule 18 (value_element -> ID .)
    IF              reduce using rule 18 (value_element -> ID .)
    WHILE           reduce using rule 18 (value_element -> ID .)
    FOR             reduce using rule 18 (value_element -> ID .)
    ID              reduce using rule 18 (value_element -> ID .)
    FLOAT           reduce using rule 18 (value_element -> ID .)
    INT             reduce using rule 18 (value_element -> ID .)
    STRING          reduce using rule 18 (value_element -> ID .)
    [               reduce using rule 18 (value_element -> ID .)


state 52

    (26) matrix_definition -> [ matrix_definition_inside . ]
    (27) matrix_definition_inside -> matrix_definition_inside . matrix_definition_inside
    (27) matrix_definition_inside -> . matrix_definition_inside matrix_definition_inside
    (28) matrix_definition_inside -> . value_element ,
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ]               shift and go to state 63
    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    matrix_definition_inside       shift and go to state 62
    value_element                  shift and go to state 53
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 53

    (28) matrix_definition_inside -> value_element . ,
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

    ,               shift and go to state 64
    TRANSPOSE       shift and go to state 34
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

    arithmetic_operator            shift and go to state 35

state 54

    (6) block -> { segment } .

    {               reduce using rule 6 (block -> { segment } .)
    IF              reduce using rule 6 (block -> { segment } .)
    WHILE           reduce using rule 6 (block -> { segment } .)
    FOR             reduce using rule 6 (block -> { segment } .)
    ID              reduce using rule 6 (block -> { segment } .)
    FLOAT           reduce using rule 6 (block -> { segment } .)
    INT             reduce using rule 6 (block -> { segment } .)
    STRING          reduce using rule 6 (block -> { segment } .)
    -               reduce using rule 6 (block -> { segment } .)
    [               reduce using rule 6 (block -> { segment } .)
    $end            reduce using rule 6 (block -> { segment } .)
    }               reduce using rule 6 (block -> { segment } .)
    ELSE            reduce using rule 6 (block -> { segment } .)


state 55

    (10) if -> IF ( logical_expression . ) group
    (11) if -> IF ( logical_expression . ) group ELSE group

    )               shift and go to state 65


state 56

    (41) logical_expression -> value_element . comparison_operator value_element
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (42) comparison_operator -> . <
    (43) comparison_operator -> . >
    (44) comparison_operator -> . EQUAL
    (45) comparison_operator -> . NOT_EQUAL
    (46) comparison_operator -> . SMALLER_OR_EQUAL
    (47) comparison_operator -> . LARGER_OR_EQUAL
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

    TRANSPOSE       shift and go to state 34
    <               shift and go to state 36
    >               shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    SMALLER_OR_EQUAL shift and go to state 40
    LARGER_OR_EQUAL shift and go to state 41
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

    comparison_operator            shift and go to state 33
    arithmetic_operator            shift and go to state 35

state 57

    (9) while -> WHILE ( logical_expression . ) group

    )               shift and go to state 66


state 58

    (7) for -> FOR ID = . range group
    (8) range -> . value_element : value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    range                          shift and go to state 67
    value_element                  shift and go to state 68
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 59

    (48) assignment -> ID = value_element .
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

    ;               reduce using rule 48 (assignment -> ID = value_element .)
    TRANSPOSE       shift and go to state 34
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

    arithmetic_operator            shift and go to state 35

state 60

    (41) logical_expression -> value_element comparison_operator value_element .
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

    ;               reduce using rule 41 (logical_expression -> value_element comparison_operator value_element .)
    )               reduce using rule 41 (logical_expression -> value_element comparison_operator value_element .)
    TRANSPOSE       shift and go to state 34
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

    arithmetic_operator            shift and go to state 35

state 61

    (29) arithmetic_expression -> value_element arithmetic_operator value_element .
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

  ! shift/reduce conflict for TRANSPOSE resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MTX_SUM resolved as shift
  ! shift/reduce conflict for MTX_DIFFERENCE resolved as shift
  ! shift/reduce conflict for MTX_PRODUCT resolved as shift
  ! shift/reduce conflict for MTX_QUOTIENT resolved as shift
    <               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    >               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    EQUAL           reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    NOT_EQUAL       reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    SMALLER_OR_EQUAL reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    LARGER_OR_EQUAL reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    ;               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    ,               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    )               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    :               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    {               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    IF              reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    WHILE           reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    FOR             reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    ID              reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    FLOAT           reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    INT             reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    STRING          reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    [               reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .)
    TRANSPOSE       shift and go to state 34
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

  ! TRANSPOSE       [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! +               [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! -               [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! *               [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! /               [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! MTX_SUM         [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! MTX_DIFFERENCE  [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! MTX_PRODUCT     [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]
  ! MTX_QUOTIENT    [ reduce using rule 29 (arithmetic_expression -> value_element arithmetic_operator value_element .) ]

    arithmetic_operator            shift and go to state 35

state 62

    (27) matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .
    (27) matrix_definition_inside -> matrix_definition_inside . matrix_definition_inside
    (27) matrix_definition_inside -> . matrix_definition_inside matrix_definition_inside
    (28) matrix_definition_inside -> . value_element ,
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for [ resolved as shift
    ]               reduce using rule 27 (matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .)
    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

  ! ID              [ reduce using rule 27 (matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .) ]
  ! FLOAT           [ reduce using rule 27 (matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .) ]
  ! INT             [ reduce using rule 27 (matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .) ]
  ! STRING          [ reduce using rule 27 (matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .) ]
  ! -               [ reduce using rule 27 (matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .) ]
  ! [               [ reduce using rule 27 (matrix_definition_inside -> matrix_definition_inside matrix_definition_inside .) ]

    matrix_definition_inside       shift and go to state 62
    value_element                  shift and go to state 53
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 63

    (26) matrix_definition -> [ matrix_definition_inside ] .

    TRANSPOSE       reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    <               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    >               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    EQUAL           reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    NOT_EQUAL       reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    SMALLER_OR_EQUAL reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    LARGER_OR_EQUAL reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    +               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    -               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    *               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    /               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    MTX_SUM         reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    MTX_DIFFERENCE  reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    MTX_PRODUCT     reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    MTX_QUOTIENT    reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    ;               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    ,               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    )               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    :               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    {               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    IF              reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    WHILE           reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    FOR             reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    ID              reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    FLOAT           reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    INT             reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    STRING          reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)
    [               reduce using rule 26 (matrix_definition -> [ matrix_definition_inside ] .)


state 64

    (28) matrix_definition_inside -> value_element , .

    ]               reduce using rule 28 (matrix_definition_inside -> value_element , .)
    ID              reduce using rule 28 (matrix_definition_inside -> value_element , .)
    FLOAT           reduce using rule 28 (matrix_definition_inside -> value_element , .)
    INT             reduce using rule 28 (matrix_definition_inside -> value_element , .)
    STRING          reduce using rule 28 (matrix_definition_inside -> value_element , .)
    -               reduce using rule 28 (matrix_definition_inside -> value_element , .)
    [               reduce using rule 28 (matrix_definition_inside -> value_element , .)


state 65

    (10) if -> IF ( logical_expression ) . group
    (11) if -> IF ( logical_expression ) . group ELSE group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    logical_expression             shift and go to state 13
    group                          shift and go to state 69
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 66

    (9) while -> WHILE ( logical_expression ) . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    logical_expression             shift and go to state 13
    group                          shift and go to state 70
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 67

    (7) for -> FOR ID = range . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    group                          shift and go to state 71
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    logical_expression             shift and go to state 13
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 68

    (8) range -> value_element . : value_element
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

    :               shift and go to state 72
    TRANSPOSE       shift and go to state 34
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

    arithmetic_operator            shift and go to state 35

state 69

    (10) if -> IF ( logical_expression ) group .
    (11) if -> IF ( logical_expression ) group . ELSE group

  ! shift/reduce conflict for ELSE resolved as shift
    {               reduce using rule 10 (if -> IF ( logical_expression ) group .)
    IF              reduce using rule 10 (if -> IF ( logical_expression ) group .)
    WHILE           reduce using rule 10 (if -> IF ( logical_expression ) group .)
    FOR             reduce using rule 10 (if -> IF ( logical_expression ) group .)
    ID              reduce using rule 10 (if -> IF ( logical_expression ) group .)
    FLOAT           reduce using rule 10 (if -> IF ( logical_expression ) group .)
    INT             reduce using rule 10 (if -> IF ( logical_expression ) group .)
    STRING          reduce using rule 10 (if -> IF ( logical_expression ) group .)
    -               reduce using rule 10 (if -> IF ( logical_expression ) group .)
    [               reduce using rule 10 (if -> IF ( logical_expression ) group .)
    $end            reduce using rule 10 (if -> IF ( logical_expression ) group .)
    }               reduce using rule 10 (if -> IF ( logical_expression ) group .)
    ELSE            shift and go to state 73

  ! ELSE            [ reduce using rule 10 (if -> IF ( logical_expression ) group .) ]


state 70

    (9) while -> WHILE ( logical_expression ) group .

    {               reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    IF              reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    WHILE           reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    FOR             reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    ID              reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    FLOAT           reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    INT             reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    STRING          reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    -               reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    [               reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    $end            reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    }               reduce using rule 9 (while -> WHILE ( logical_expression ) group .)
    ELSE            reduce using rule 9 (while -> WHILE ( logical_expression ) group .)


state 71

    (7) for -> FOR ID = range group .

    {               reduce using rule 7 (for -> FOR ID = range group .)
    IF              reduce using rule 7 (for -> FOR ID = range group .)
    WHILE           reduce using rule 7 (for -> FOR ID = range group .)
    FOR             reduce using rule 7 (for -> FOR ID = range group .)
    ID              reduce using rule 7 (for -> FOR ID = range group .)
    FLOAT           reduce using rule 7 (for -> FOR ID = range group .)
    INT             reduce using rule 7 (for -> FOR ID = range group .)
    STRING          reduce using rule 7 (for -> FOR ID = range group .)
    -               reduce using rule 7 (for -> FOR ID = range group .)
    [               reduce using rule 7 (for -> FOR ID = range group .)
    $end            reduce using rule 7 (for -> FOR ID = range group .)
    }               reduce using rule 7 (for -> FOR ID = range group .)
    ELSE            reduce using rule 7 (for -> FOR ID = range group .)


state 72

    (8) range -> value_element : . value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    ID              shift and go to state 51
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    value_element                  shift and go to state 74
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 73

    (11) if -> IF ( logical_expression ) group ELSE . group
    (12) group -> . conditional
    (13) group -> . line
    (14) group -> . block
    (15) conditional -> . if
    (16) conditional -> . while
    (17) conditional -> . for
    (5) line -> . expression ;
    (6) block -> . { segment }
    (10) if -> . IF ( logical_expression ) group
    (11) if -> . IF ( logical_expression ) group ELSE group
    (9) while -> . WHILE ( logical_expression ) group
    (7) for -> . FOR ID = range group
    (38) expression -> . logical_expression
    (39) expression -> . assignment
    (40) expression -> . value_element
    (41) logical_expression -> . value_element comparison_operator value_element
    (48) assignment -> . ID = value_element
    (18) value_element -> . ID
    (19) value_element -> . arithmetic_expression
    (20) value_element -> . FLOAT
    (21) value_element -> . INT
    (22) value_element -> . STRING
    (23) value_element -> . - value_element
    (24) value_element -> . value_element TRANSPOSE
    (25) value_element -> . matrix_definition
    (29) arithmetic_expression -> . value_element arithmetic_operator value_element
    (26) matrix_definition -> . [ matrix_definition_inside ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    FOR             shift and go to state 15
    ID              shift and go to state 16
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    STRING          shift and go to state 22
    -               shift and go to state 23
    [               shift and go to state 25

    logical_expression             shift and go to state 13
    group                          shift and go to state 75
    conditional                    shift and go to state 4
    line                           shift and go to state 5
    block                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 17
    value_element                  shift and go to state 18
    arithmetic_expression          shift and go to state 19
    matrix_definition              shift and go to state 24

state 74

    (8) range -> value_element : value_element .
    (24) value_element -> value_element . TRANSPOSE
    (29) arithmetic_expression -> value_element . arithmetic_operator value_element
    (30) arithmetic_operator -> . +
    (31) arithmetic_operator -> . -
    (32) arithmetic_operator -> . *
    (33) arithmetic_operator -> . /
    (34) arithmetic_operator -> . MTX_SUM
    (35) arithmetic_operator -> . MTX_DIFFERENCE
    (36) arithmetic_operator -> . MTX_PRODUCT
    (37) arithmetic_operator -> . MTX_QUOTIENT

  ! shift/reduce conflict for - resolved as shift
    {               reduce using rule 8 (range -> value_element : value_element .)
    IF              reduce using rule 8 (range -> value_element : value_element .)
    WHILE           reduce using rule 8 (range -> value_element : value_element .)
    FOR             reduce using rule 8 (range -> value_element : value_element .)
    ID              reduce using rule 8 (range -> value_element : value_element .)
    FLOAT           reduce using rule 8 (range -> value_element : value_element .)
    INT             reduce using rule 8 (range -> value_element : value_element .)
    STRING          reduce using rule 8 (range -> value_element : value_element .)
    [               reduce using rule 8 (range -> value_element : value_element .)
    TRANSPOSE       shift and go to state 34
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    MTX_SUM         shift and go to state 46
    MTX_DIFFERENCE  shift and go to state 47
    MTX_PRODUCT     shift and go to state 48
    MTX_QUOTIENT    shift and go to state 49

  ! -               [ reduce using rule 8 (range -> value_element : value_element .) ]

    arithmetic_operator            shift and go to state 35

state 75

    (11) if -> IF ( logical_expression ) group ELSE group .

    {               reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    IF              reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    WHILE           reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    FOR             reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    ID              reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    FLOAT           reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    INT             reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    STRING          reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    -               reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    [               reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    $end            reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    }               reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)
    ELSE            reduce using rule 11 (if -> IF ( logical_expression ) group ELSE group .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for { in state 26 resolved as shift
WARNING: shift/reduce conflict for IF in state 26 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 26 resolved as shift
WARNING: shift/reduce conflict for FOR in state 26 resolved as shift
WARNING: shift/reduce conflict for ID in state 26 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 26 resolved as shift
WARNING: shift/reduce conflict for INT in state 26 resolved as shift
WARNING: shift/reduce conflict for STRING in state 26 resolved as shift
WARNING: shift/reduce conflict for - in state 26 resolved as shift
WARNING: shift/reduce conflict for [ in state 26 resolved as shift
WARNING: shift/reduce conflict for TRANSPOSE in state 61 resolved as shift
WARNING: shift/reduce conflict for + in state 61 resolved as shift
WARNING: shift/reduce conflict for - in state 61 resolved as shift
WARNING: shift/reduce conflict for * in state 61 resolved as shift
WARNING: shift/reduce conflict for / in state 61 resolved as shift
WARNING: shift/reduce conflict for MTX_SUM in state 61 resolved as shift
WARNING: shift/reduce conflict for MTX_DIFFERENCE in state 61 resolved as shift
WARNING: shift/reduce conflict for MTX_PRODUCT in state 61 resolved as shift
WARNING: shift/reduce conflict for MTX_QUOTIENT in state 61 resolved as shift
WARNING: shift/reduce conflict for ID in state 62 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 62 resolved as shift
WARNING: shift/reduce conflict for INT in state 62 resolved as shift
WARNING: shift/reduce conflict for STRING in state 62 resolved as shift
WARNING: shift/reduce conflict for - in state 62 resolved as shift
WARNING: shift/reduce conflict for [ in state 62 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 69 resolved as shift
WARNING: shift/reduce conflict for - in state 74 resolved as shift
